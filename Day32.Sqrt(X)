Approach: Computing the Square Root Using Binary Search
1ï¸âƒ£ Understanding the Problem
We need to compute the integer square root of a given number x.
The square root of x is the largest integer r such that 
ğ‘Ÿ
2
â‰¤
ğ‘¥
r 
2
 â‰¤x.
We should not use built-in functions like sqrt(x).
The problem requires efficient computation, especially for large x.
2ï¸âƒ£ Thought Process
Since the square root function is monotonic (increasing function), Binary Search is a perfect approach.
We search for r such that 
ğ‘Ÿ
2
â‰¤
ğ‘¥
r 
2
 â‰¤x and 
(
ğ‘Ÿ
+
1
)
2
>
ğ‘¥
(r+1) 
2
 >x.
3ï¸âƒ£ Steps to Solve the Problem
Step 1: Handle Edge Case
If x == 0, return 0 immediately.
Step 2: Binary Search on Possible Square Roots
Set left = 1 and right = x (since sqrt(x) never exceeds x).
Compute mid as the middle of the search range.
Check conditions:
If 
ğ‘š
ğ‘–
ğ‘‘
2
=
=
ğ‘¥
mid 
2
 ==x, return mid (exact square root found).
If 
ğ‘š
ğ‘–
ğ‘‘
2
<
ğ‘¥
mid 
2
 <x, move left to mid + 1 (search in the higher range).
If 
ğ‘š
ğ‘–
ğ‘‘
2
>
ğ‘¥
mid 
2
 >x, move right to mid - 1 (search in the lower range).
The loop stops when left > right, and right stores the floor value of sqrt(x).
4ï¸âƒ£ Complexity Analysis
Time Complexity:
ğ‘‚(logâ¡ğ‘¥)
O(logx) â†’ Since we halve the search space in each step.
Space Complexity:
ğ‘‚
(
1
)
O(1) â†’ No extra space used.
6ï¸âƒ£ Final Thoughts
âœ” Why Binary Search? â†’ Fastest method (logarithmic complexity).
âœ” Why return right? â†’ At the end, right will hold the largest r such that 
ğ‘Ÿ
2
â‰¤
ğ‘¥
r 
2
 â‰¤x.
âœ” Handles large inputs efficiently â†’ Prevents overflow by using mid = x / mid instead of mid * mid.

 class Solution {
public:
    int mySqrt(int x) {
        // return sqrt(x);
        if(x==0) return 0;
        int left=1,right=x;
        while(left<=right)
        {
            int mid=left+(right-left)/2;
            
                if(mid==x/mid)
                {
                    return mid;
                }
                else if(mid<x/mid)
                {
                    left=mid+1;
                }
                else
                {
                    right=mid-1;
                }
            
        }
        return right;
    }
};
